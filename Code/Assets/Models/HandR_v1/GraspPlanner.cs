using Microsoft.SolverFoundation.Common;
using Microsoft.SolverFoundation.Services;
using Microsoft.SolverFoundation.Solvers;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;
using Matrix4x4 = UnityEngine.Matrix4x4;
using Quaternion = UnityEngine.Quaternion;
using Vector3 = UnityEngine.Vector3;
using Vector4 = UnityEngine.Vector4;
using Random = UnityEngine.Random;
using System.IO;
using System.Diagnostics;
using System.Diagnostics.Contracts;

public class GraspPlanner : MonoBehaviour
{



    /* references set by dragging objects into the corresponding fields of this component in Unity */
    public GameObject HandModel; // the hand model
    public GameObject GraspSubject; // subject place holder


    // prefab for visualising contact points, drag into unity inspector
    public GameObject ContactPointPrefab;
    public GameObject ContactPointPrefabRed;

    public GameObject RayIndicatorPrefab; // a prefab for visualizing a ray which you can instantiate for debugging purposes.

    /* auto derived references */
    private DOF _handModelDOF;  // DOF component reference of the handmodel
    private Rigidbody _subjectRigidbody;    // rigidbody component for the subject

    /* instances of utilitiy classes */
    public Logger logger; // for logging to a file

    private System.Random _rand;


    /* events */
    public event EventHandler StepAccepted; // called when a step of optimization is accetped.

    /* boolean flags for setting planner modes */
    public bool Is_Eigen { get; set; } // if set to true, use eigengrasp, otherwise original DOFs

        // if set to true, use predefined sphere colliders on some specific locations on the hand model instead of the collider(s) for the whole hand
        // for example, 5 on the fingertips and 1 on the palm
    public bool Is_selectedContact  
    {
        get { return _handModelDOF.Is_selectedContact; }
        set
        {
            _handModelDOF.Is_selectedContact = value;
        }
    }

    public bool Is_singleStep { get; private set; } // whether the planner stops at next valid step

    public bool Is_ContactPointOptimizer { get; set; } // true if optimizing contact points

    public bool Is_manualControl    // true if manualling control the hand model
    {
        get
        {
            return _handModelDOF.Is_manualControl;
        }

        set
        {
            if (!value)
            {
                ClearPreviousContactPointsOnScreen();
            }

            _handModelDOF.Is_manualControl = value;
        }
    }

    /* data storage */

    // independent variables for each step in optimization.
    // vanilla DoF mode. array sizes: 6 (for the wrist) + Joint DoFs count
    private float[] _currentData;   // DoFs data for the last accepted step
    private float[] _minValues;     // minimum values for each DoF
    private float[] _maxValues;     // maximum values for each DoF
    private float[] _nextBuffer;    // the DoFs data for next step


    // eigengrasp mode. Likewise.
    private float[] _currentDataEigen;
    private float[] _minValuesEigen;
    private float[] _maxValuesEigen;
    private float[] _nextBufferEigen;

    public int EigenPCCount { get; set; } // how many pricinpal components to use in eigengrasp mode

    // returns the right data for the current mode
    private float[] CurrentData { get { return Is_Eigen ? _currentDataEigen : _currentData; } }
    private float[] MinValues { get { return Is_Eigen ? _minValuesEigen : _minValues; } }
    private float[] MaxValues { get { return Is_Eigen ? _maxValuesEigen : _maxValues; } }
    private float[] NextBuffer { get { return Is_Eigen ? _nextBufferEigen : _nextBuffer; } }


    //


    // whole hand colliding mode
    private List<ContactPoint> _contacts;   // contact points generated by unity's phisycs engine
    private List<ContactPoint> _lastAcceptedContacts; // contact points for last accepted step

    // selected contact mode
    private List<Ray> _imaginaryContacts;   // imaginary contact points on the object for each of the predefined contact locations (sphere colliders)
    private List<Ray> _lastAcceptedImaginaryContacts; // imanginary contact poitns on the object for last accepted step

    private SphereCollider[] _selectedContactPoints // storing the colliders for the predefined contact locations
    {
        get
        {
            return _handModelDOF.SelectedContactPoints;
        }
    }

    SphereCollider _minDistanceCollider;    // the collider among the sphere colliders that has the minimum distance from the object.
    Ray? _closestPointOnSubject;    // the closest point on the subject from all the sphere colliders


    //

    // constrain the position of the wrist. The wrist can move within the sphere of a radius of this value centered at subjectCenterOfMass.
    // i.e. the hand can move within the range of [subjectCenterOfMass.? - value, subjectCenterOfMass.? + value] for ? belongs to {x, y, z}
    private float _transformHalfRangeForEachAxis; 

    public float TransformHalfRangeForEachAxis
    {
        get
        {
            return _transformHalfRangeForEachAxis;
        }
        set
        {
            for(var i=0; i<3; i++)
            {
                var min = _subjectCenterOfMass[i] - value;
                var max = _subjectCenterOfMass[i] + value;

                _minValues[i] = min;
                _maxValues[i] = max;

                _minValuesEigen[i] = min;
                _maxValuesEigen[i] = max;
            }

            _transformHalfRangeForEachAxis = value;
        }
    }


    //


    public float FrictionCoefficient { get; set; }  // friction coefficient

    public bool Is_planning { get; private set; }   // whether the planner is planning

    public bool Is_calculatingQualty { get; private set; }  // multi-threading flag



    public bool Is_contactPointsVisualized { get; private set; }    // whether the contact points are visualized with prefab


    // simulated annealing config
    public int Iterations {get; private set;}   // current iteration count

    public int? MaxIterations; // stops the planner when Iterations exceed this value. set to null to disable this constraint. 

    public double Proba { get; private set; } // random value between 0 and 1. this value is compared to _acceptanceProbability to determine whether or not to accept the downhill step
    private double _acceptanceProbability; // the probability threshold to accept the downhill step. dependent on the temperature and energy difference.
    public double Alpha { get; set; }   // temperature decay
    public double Temperature { get; set; } 
    public double? Epsilon { get; set; }  // stops the planner when temperature is less than this value. set to null to disable this constraint
    public double Delta { get; private set; }   // energy (score) difference between the next potential step and last accepted step

    public double ValidStepThreshold { get; set; }  // the score threashold to accept a step. Any step with a score lower than this value will be rejceted.
    

    private bool _is_stepApplied;   // whether or not the next step is accpeted.

    public double NextScore { get; private set; }   // next step score
    public double AcceptedScore { get; set; }   // last accepted step score

    public double ScoreBuffer { get; private set; } // for calculating quality measure in a sub thread


    // collision detection

    Vector3 _subjectCenterOfMass;   // center of mass of the grasp subject


    public int AccpetedContactCount { get; private set; } // contact point count


    private Vector3 directionTowardsHandModel;

    private List<UnityEngine.Object> _visualisedContactPoints; // contact point prefab instances


    // force closure
    private List<float[]> _primitiveWrenches;  // primitive wrenches for the contacts

    public float DistancePenaltyMultiplier { get; set; }    // distance penalty

    // linear programming
    private List<float[]> _constraints; // w X <= 1
    private List<float[]> _constraintsDisplaced; // (w - P) X <= 1 



    private Collider[] SubjectColliders;    // subject colliders

    // wrench directions for quality calculation
    public List<Ray> QualityMeasureForceDirections { get; set; } // force directions and the locations for the Directions of Interest (DoIs)

    private List<float[]> qualityMeasureWrenchDirections; // corresponding wrench directions for the DoIs.

    public double ScoreMultiplier { get; set; } // the final score will be multiplied by this factor

    public bool Is_AccumulatingContacts { get; set; }   // if true, do not auto clear the contact points.


    // contact point optimizer

    private int _contactCount;
    public int ContactCount
    {
        get { return _contactCount; }
        set
        {
            _nextContactPoints.Clear();
            _lastAcceptedContactPoints.Clear();
            _contactCount = value;
        }
    }

    private List<Ray> _nextContactPoints;   // contact points for next step
    private List<Ray> _lastAcceptedContactPoints; // contact points for last accetped step
    // bounding box for the subject colliders. 
    // random points are generated outside of this box. Then the closest points on the object to these random points are found and be used as contact points.
    private Bounds _subjectCollidersBounds; 


    public bool Is_QualityUpdatedOnCollisionStay { get; set; }




    /* Unity lifecycle hooks */



    private void Awake()
    {
        StepAccepted += LogOnStepAccepted; // add event handler
    }

    void Start()
    {
        var rb = GetComponent<Rigidbody>();
        rb.ResetCenterOfMass();
        _subjectCenterOfMass = rb.worldCenterOfMass;
        //rb.isKinematic = true;

        if (HandModel && GraspSubject && ContactPointPrefab && ContactPointPrefabRed)
        {
            Init();
        }
        
    }

    void FixedUpdate()
    {
        if (Is_planning && !_is_stepApplied)
        {
            if (Epsilon.HasValue && Temperature <= Epsilon ||
                MaxIterations.HasValue && Iterations > MaxIterations)
            {
                Is_planning = false;
                return;
            }
            //while the temperature did not reach epsilon

            Iterations++;

            if (Is_ContactPointOptimizer)
            {   // random step for contact points
                ComputeNextRandomContactPoints();

            }
            else
            {   // random step for hand
                ClearContacts();
                Is_AccumulatingContacts = true;
                ComputeNextStep();
                if (!Is_Eigen)
                {
                    _handModelDOF.ApplyDOFs(NextBuffer);
                }
                else
                {
                    // TODO check joint constraints
                    _handModelDOF.ApplyEigen(NextBuffer, EigenPCCount);
                }

            }



            _is_stepApplied = true;

            //_is_Planning = false;
        }
    }

    // one frame one step
    void Update()
    {

        if (!Is_planning || !_is_stepApplied) return;

        double nextStepScore;
        try
        {
            if (Is_ContactPointOptimizer)
            {
                nextStepScore = CalculateContactPointsQuality();
            }
            else if (Is_selectedContact)
            {
                nextStepScore = CalculateQualityOnSelectedPoints();
            }
            else
            {
                nextStepScore = CalculateQualityMeasure();
            }


        }
        catch (NullReferenceException)
        {
            nextStepScore = float.NegativeInfinity;
        }

        NextScore = nextStepScore;

        double _energyCurr = AcceptedScore;
        // energy difference
        Delta = nextStepScore - _energyCurr;
        //if the new distance is better accept it and assign it

        bool is_MoveAccpeted = false;

        if (Delta > 0)
        {
            _energyCurr = nextStepScore;
            is_MoveAccpeted = true;
        }
        else
        {
            Proba = _rand.NextDouble();
            //if the new distance is worse accept 
            //it but with a probability level
            //if the probability is less than 
            //E to the power -delta/temperature.
            //otherwise the old value is kept

            // no need to accept the move if there's no contact

            _acceptanceProbability = Math.Exp(Delta / Temperature);





            if (nextStepScore > ValidStepThreshold && Proba < _acceptanceProbability)
            {
                _energyCurr = nextStepScore;
                is_MoveAccpeted = true;
                //print(string.Format("proba: {0}, RHS: {1}, delta: {2}, temp: {3}", 
                //    proba, _acceptanceProbability, delta, temperature));
            }
        }
        Temperature *= Alpha;
        // rewind
        if (is_MoveAccpeted)
        {
            if (Is_ContactPointOptimizer)
            {
                _lastAcceptedContactPoints = new List<Ray>(_nextContactPoints);
            }
            else
            {
                Array.Copy(NextBuffer, CurrentData, CurrentData.Length);
            }

            if (Is_singleStep)
            {
                Is_planning = false;

            }

            if (Is_selectedContact)
            {
                _lastAcceptedImaginaryContacts = new List<Ray>(_imaginaryContacts);
            }
            else
            {
                _lastAcceptedContacts = new List<ContactPoint>(_contacts);
            }


            if (Is_contactPointsVisualized)
            {
                ClearPreviousContactPointsOnScreen();
                VisualiseContactPoints();
            }

            AcceptedScore = NextScore;
            AccpetedContactCount = _contacts.Count;
            OnStepAccepted();
        }
        else
        {
            if (!Is_ContactPointOptimizer)
            {
                RollBackHandDoF();
            }


        }

        _is_stepApplied = false;



    }

    /* other methods */

    // event trigger
    protected virtual void OnStepAccepted()
    {
        if (StepAccepted != null)
        {
            StepAccepted(this, null);
        }
    }

    // a event handler. log the progress
    private void LogOnStepAccepted(object src, EventArgs args)
    {
        if (logger != null)
        {
            logger.WriteLine(string.Format(
                "{0},{1},{2}", Iterations, AcceptedScore, logger.TimeElapsedSinceStart()
                ));
        }
    }

    
    public void Init(GameObject handmodel, GameObject graspSubject, GameObject contactPointPrefab, GameObject ContactPointPrefabRed)
    {
        this.HandModel = handmodel;
        this.GraspSubject = graspSubject;
        this.ContactPointPrefab = contactPointPrefab;
        this.ContactPointPrefabRed = ContactPointPrefabRed;
        Init();
    }

    private async void Init()
    {

        _rand = new System.Random();

        // collision detection
        _handModelDOF = HandModel.GetComponent<DOF>();


        _subjectRigidbody = GraspSubject.GetComponent<Rigidbody>();
        _subjectRigidbody.ResetCenterOfMass();
        _subjectCenterOfMass = _subjectRigidbody.worldCenterOfMass;

        //_qualityMeasure = new QualityMeasure(_subjectCenterOfMass);
        //print(_subjectCenterOfMass);




        // not eigen
        // first 6 for the wrist following 23 for the joints
        _currentData = new float[29];
        _nextBuffer = new float[29];
        await Task.Run(() =>
        {
            while (_handModelDOF.JointMinValues == null)
            {

            };
            _minValues = _handModelDOF.JointMinValues;
        }
        );

        await Task.Run(() =>
        {
            while (_handModelDOF.JointMaxValues == null)
            {

            };
            _maxValues = _handModelDOF.JointMaxValues;
        }
        );

        for (int i = 0; i < 3; i++)
        {
            _minValues[i] = _subjectCenterOfMass[i] - 5f;
            _maxValues[i] = _subjectCenterOfMass[i] + 5f;
        }

        for (int i = 3; i < 6; i++)
        {
            _minValues[i] = -180;
            _maxValues[i] = 180;
        }



        // eigen
        _currentDataEigen = new float[12];
        _nextBufferEigen = new float[12];

        _minValuesEigen = new float[12]
        {
            0, 0, 0,
            -180, -180, -180,
            -200, -200, -200, -200, -200, -200
        };

        _maxValuesEigen = new float[12]
        {
            0, 0, 0,
            180, 180, 180,
            100, 100, 100, 100, 100, 100

        };



        _contacts = new List<ContactPoint>();

        UnityEngine.Debug.Log("GraspPlanner " + _contacts.Count);


        OptimizerInit();
        QualityMeasureInit();
        ContactPointOptimizerInit();

        // visualize contact
        _visualisedContactPoints = new List<UnityEngine.Object>();

        SubjectColliders = GetComponentsInChildren<MeshCollider>();
        //print("Grasp planner init");
        // tests
        //TestRotationMatrix();
        //TestLpSolver();
    }

    private void ContactPointOptimizerInit()
    {
        _nextContactPoints = new List<Ray>();
        _lastAcceptedContactPoints = new List<Ray>();
        _contactCount = 6;
    }

    private void QualityMeasureInit(bool resetParameters = true)
    {
        if (resetParameters)
        {
            ScoreMultiplier = 10000.0;
            FrictionCoefficient = 0.4f;
            DistancePenaltyMultiplier = 0.1f;
            ForceClosureInit();
            QualityMeasureDirectionsInit();
        }

        
        
    }



    private void OptimizerInit()
    {
        Is_Eigen = false;
        EigenPCCount = 4;
        TransformHalfRangeForEachAxis = 2f;

        Iterations = -1;

        Is_selectedContact = _handModelDOF.Is_selectedContact;




        ValidStepThreshold = 0;
        //ValidStepThreshold = Double.NegativeInfinity;

        if (!_handModelDOF.Is_meshCollider && Is_selectedContact)
        {
            Alpha = 0.9996; // default 0.999
            Temperature = 100.0; // default 400.0
            Epsilon = 0.001;

        }
        else if (_handModelDOF.Is_meshCollider)
        {
            Alpha = 0.999; // default 0.999
            Temperature = 4000.0; // default 400.0
            Epsilon = 0.001;

        }
        else
        {
            Alpha = 0.999; // default 0.999
            Temperature = 4000.0; // default 400.0
            Epsilon = 0.001;
        }


    }

    // DoIs init
    private void QualityMeasureDirectionsInit()
    {
        QualityMeasureForceDirections = new List<Ray>();
        qualityMeasureWrenchDirections = new List<float[]>();

        // gravity
        var force = Vector3.down;
        QualityMeasureForceDirections.Add(new Ray(_subjectCenterOfMass, force));

        UpdateQualityMeasureWrenchDirections();

    }

    private void ForceClosureInit()
    {
        _primitiveWrenches = new List<float[]>();
        //_distanceFromHandToSubject = float.PositiveInfinity;
        _constraints = new List<float[]>();
        _constraintsDisplaced = new List<float[]>();
    }



    public void SetSelectedContact(bool is_enabled)
    {
        Is_selectedContact = is_enabled;
    }

    // rewind to last accepted step
    public void RollBackHandDoF()
    {
        if (!Is_Eigen)
        {
            _handModelDOF.ApplyDOFs(CurrentData);
        }
        else
        {
            _handModelDOF.ApplyEigen(CurrentData);
        }
    }

    // reset the planner and the hand model
    public void ResetAll(bool ignoreQualityMeasureParameters = false)
    {
        Is_planning = false;
        _handModelDOF.ResetTransform();
        OptimizerInit();
        ContactPointOptimizerInit();
        QualityMeasureInit(!ignoreQualityMeasureParameters);

    }

    // ray is a force with the point where it is applied
    // returns a wrench for the force applied at that certain point with the torque component calculated relative to the object's center of mass
    private float[] GetWrenchRelativeToObjectCenterOfMess(Ray ray)
    {
        var wrench = new float[6];
        var force = ray.direction;
        var torque = Vector3.Cross(ray.origin - _subjectCenterOfMass, force);
        wrench[0] = force.x;
        wrench[1] = force.y;
        wrench[2] = force.z;

        wrench[3] = torque.x;
        wrench[4] = torque.y;
        wrench[5] = torque.z;

        return wrench;
    }



    // must be called after making changes to QualityMeasureForceDirecdtions to update the wrenches for the DoIs
    public void UpdateQualityMeasureWrenchDirections()
    {
        qualityMeasureWrenchDirections.Clear();

        foreach (var forceDirection in QualityMeasureForceDirections)
        {
            var wrenchDirection = GetWrenchRelativeToObjectCenterOfMess(forceDirection);
            qualityMeasureWrenchDirections.Add(wrenchDirection);
        }
    }


    // solves linear programming problem
    /*
     * constraints: rows of constrant inequalities, LHS <= RHS
     *  e.g. 2X + 3Y + Z <= 50
     *      constrant[0] = new float[] {2, 3, 1, 50}
     * 
     * objectiveFunction: coefficients for independent variables
     *  e.g. P = 2X + 3Y + 0Z:
     *      objectiveFunction = new float[] {2, 3, 0}
     *
     *  objective function will be maximized
     */
    private SimplexSolver SolveLpProblem(List<float[]> constraints, float[] objectiveFunction)
    {
        SimplexSolver solver = new SimplexSolver();

        const string P = "OF"; // objective function
        int dimensions = objectiveFunction.Length;

        // assign var names
        string[] varNames = new string[dimensions];
        for (int i = 0; i < dimensions; i++)
        {
            varNames[i] = "X" + i;
        }

        // out temp variables 
        int vid; // var id
        int rid; // row id


        // Set vars
        // independent vars
        foreach (string varName in varNames)
        {
            solver.AddVariable(varName, out vid);
            // TODO verify lower-bound could be less than 0
            solver.SetBounds(vid, Rational.NegativeInfinity, Rational.PositiveInfinity);
        }

        // objective function
        solver.AddVariable(P, out vid);
        solver.SetBounds(vid, Rational.NegativeInfinity, Rational.PositiveInfinity);


        // set constraints
        for (int i = 0; i < constraints.Count; i++)
        {
            solver.AddRow(string.Format("constrant{0}", i), out rid);
            var row = constraints[i];
            for (int j = 0; j < varNames.Length; j++)
            {
                try{
                    solver.SetCoefficient(rid, solver.GetIndexFromKey(varNames[j]), row[j]);
                }catch (ArgumentException ae)
                {
                    UnityEngine.Debug.Log(ae.Message);
                    return null;
                }
                
            }

            solver.SetBounds(rid, Rational.NegativeInfinity, row[row.Length - 1]);
            //print(row[row.Length - 1]);

        }

        // objective
        solver.AddRow("Objective", out rid);
        for (int i = 0; i < varNames.Length; i++)
        {
            solver.SetCoefficient(rid, solver.GetIndexFromKey(varNames[i]), objectiveFunction[i]);
        }

        solver.SetCoefficient(rid, solver.GetIndexFromKey(P), -1);
        solver.SetBounds(rid, 0, 0);

        // add goal 
        solver.AddRow("Goal", out rid);
        solver.SetCoefficient(rid, solver.GetIndexFromKey(P), 1);

        // add objective (goal) to model and specify minimization (==false)
        solver.AddGoal(rid, 1, false);


        //optimize
        //SimplexSolverParams parameter1 = new SimplexSolverParams();
        //parameter1.Algorithm = SimplexAlgorithmKind.Primal;
        //parameter1.Costing = SimplexCosting.SteepestEdge;
        //parameter1.InitialBasisKind = SimplexBasisKind.Slack;
        //parameter1.UseExact = true;

        //SimplexSolverParams parameter2 = new SimplexSolverParams();
        //parameter2.Algorithm = SimplexAlgorithmKind.Dual;
        //solver.Solve(parameter1, parameter2);

        //_logger.WriteLine("start solving");

        ThreadStart LpSolvingThreadRef = new ThreadStart(() => { solver.Solve(new SimplexSolverParams()); });

        Thread LpSolvingThread = new Thread(LpSolvingThreadRef);


        const int maxCalculationTime = 1; // in seconds

        var tStart = DateTime.Now;
        var tEnd = tStart.AddSeconds(maxCalculationTime);

        LpSolvingThread.Start();

        bool is_calculationFinished = false;

        while (DateTime.Now < tEnd)
        {
            if (LpSolvingThread.ThreadState == System.Threading.ThreadState.Stopped)
            {
                is_calculationFinished = true;
                break;
            }
        }

        if (is_calculationFinished)
        {
            LpSolvingThread.Join();
            return solver;
        }


        LpSolvingThread.Abort();
        solver.Shutdown();

        return null;



        //_logger.WriteLine("problem solved");
    }
    



    public void TogglePlanner()
    {
        Is_planning = !Is_planning;
        _is_stepApplied = false;
        RollBackHandDoF();
    }

    public void SetSingleStep(bool newVal)
    {
        Is_singleStep = newVal;
    }

    public void ToggleSingleStep()
    {
        Is_singleStep = !Is_singleStep;
    }

    public void ToggleContactPointIndicators()
    {
        SetContactIndicatorActive(!Is_contactPointsVisualized);
    }

    public void SetContactIndicatorActive(bool newVal)
    {
        Is_contactPointsVisualized = newVal;
        ClearPreviousContactPointsOnScreen();
        if (Is_contactPointsVisualized)
        {
            VisualiseContactPoints();
        }
    }




    private void ComputeNextStep()
    {
        for (int i = 0; i < CurrentData.Length; i++)
        {
            float randomVal = (float) _rand.NextDouble();
            NextBuffer[i] = randomVal * (MaxValues[i] - MinValues[i]) + MinValues[i];
        }


        //print(_nextBuffer);
    }




    // calculate the primitive wrenches for a contact point
    /*
     * contactPosition : world location of the contact point
     * contactNormal: surface normal at the contact point
     * frictionConeEdges: number of edges used to approximate the friction cone
     * 
     */

    private void CalculatePrimitiveWrenchForAContact(Vector3 contactPosition, Vector3 contactNormal, int frictionConeEdges)
    {
        float edgeRotationInterval = 360 / frictionConeEdges;

        var positionVector = contactPosition - _subjectCenterOfMass;
        var normal = contactNormal.normalized;
        float edgeY = (float)Math.Sqrt(
            (FrictionCoefficient * FrictionCoefficient) * (normal.z * normal.z) /
            (normal.z * normal.z + normal.y * normal.y));

        Vector3 frictionForce = new Vector3(0, edgeY, -(normal.y * edgeY) / normal.z);
        Vector3 edge0 = normal + frictionForce;
        Vector3 edgeTorque = Vector3.Cross(positionVector, edge0);

        var primitiveWrench = CreateWrench(edge0, edgeTorque);

        _primitiveWrenches.Add(primitiveWrench);

        float currentRotationDegree = 0f;
        

        for (int i = 0; i<frictionConeEdges - 1; i++)
        {
            currentRotationDegree += edgeRotationInterval;
            var transformationMatrix = GetRotationMatix(normal, currentRotationDegree);
            Vector3 anotherEdge = transformationMatrix.MultiplyVector(edge0);
            var anotherEdgeTorque = Vector3.Cross(positionVector, anotherEdge);
            var anotherPrimitiveWrench = CreateWrench(anotherEdge, anotherEdgeTorque);
            _primitiveWrenches.Add(anotherPrimitiveWrench);
        }
    }

    // generates primitive wrenches and checks force closure, 
    // returns true if and only if the grasp is in force-closure
    private bool CheckForceClosure(List<Ray> contactPointAndNormalPairs)
    {
        // generate primitive wrenches
        _primitiveWrenches.Clear();
        //_primitiveWrenchesDistances.Clear();
        const int FrictionConeEdges = 7;



        if(contactPointAndNormalPairs == null)
        {
            foreach (var contact in _contacts)
            {
                CalculatePrimitiveWrenchForAContact(contact.point, contact.normal, FrictionConeEdges);

            }
        }
        else
        {

            for (var i = 0; i < contactPointAndNormalPairs.Count; i++)
            {
                var contact = contactPointAndNormalPairs[i];
                CalculatePrimitiveWrenchForAContact(contact.origin, contact.direction, FrictionConeEdges);
            }

        }


        // linear programming
        // chose a point that is always inside the convex hull
        float[] innerPoint = new float[6];
        float[] PO = new float[6];

        foreach (var primitiveWrench in _primitiveWrenches)
        {
            for (int i = 0; i < 6; i++)
            {
                innerPoint[i] += primitiveWrench[i];
            }
        }

        int N = _primitiveWrenches.Count;
        for (int i = 0; i < 6; i++)
        {
            innerPoint[i] /= N;
            PO[i] = -innerPoint[i];
        }


        // (wi - P)T x <= 1 convex polytope

        _constraintsDisplaced.Clear();
        _constraints.Clear();

        var wrenchItr = _primitiveWrenches.GetEnumerator();
        for (int i = 0; i < _primitiveWrenches.Count; i++)
        {
            wrenchItr.MoveNext();
            var wrenchCurr = wrenchItr.Current;
            var constraint = new float[7];
            var constraintDisplaced = new float[7];
            for (int j = 0; j < 6; j++)
            {
                constraint[j] = wrenchCurr[j];
                constraintDisplaced[j] = wrenchCurr[j] - innerPoint[j];
            }

            constraint[6] = 1; // RHS
            constraintDisplaced[6] = 1; // RHS
            _constraintsDisplaced.Add(constraintDisplaced);
            _constraints.Add(constraint);
        }

        float[] objectiveFunction = PO;


        var solver = SolveLpProblem(_constraintsDisplaced, objectiveFunction);
        if (solver == null) return false;


        if (solver.Result == LinearResult.Invalid)
        {
            solver.Shutdown();
            solver = null;
            return false;
        }


        // find the point that vector PO intersects with the convex polytope
        float[] varVals = GetVarValuesFromResult(solver);


        var intersection = CalculateRayInterSectionWithFacet(PO, varVals);

        float distancePQ = CalculateSqrDistanceR6(intersection, innerPoint);
        float distancePO = CalculateSqrDistanceR6(null, innerPoint);

        //print(string.Format("PQ:{0}, P0:{1}", distancePQ, distancePO));

        solver.Shutdown();
        solver = null;

        return distancePQ > distancePO;
    }

    // returns true if and only if the grasp is in force closure
    private bool CheckForceClosure()
    {
        return CheckForceClosure(null);
        
    }


    // calculates the intersection of the ray with the facet (hyperplane)
    // ray, facet : R6
    // for facet: e0X0 + e1X1 + e2X2 + e3X3 + e4X4 + e5X5  = 1, facet = {e0, e1, e2, e3, e4, e5} 
    private float[] CalculateRayInterSectionWithFacet(float[] ray, float[] facet)
    {
        int firstNonZeroCoordinateIndex = -1;
        for (int i = 0; i < 6; i++)
        {
            if (Math.Abs(ray[i]) > float.Epsilon)
            {
                firstNonZeroCoordinateIndex = i;
                break;
            }
        }

        if(firstNonZeroCoordinateIndex < 0) 
            throw new InvalidOperationException("ray cannot be zero vector");

        float[] rayCoordinatesMultiplesToBaseCoordinate = new float[6];
        for (int i = 0; i < 6; i++)
        {
            rayCoordinatesMultiplesToBaseCoordinate[i] = ray[i] / ray[firstNonZeroCoordinateIndex];
        }

        float baseCoordinateScalar = 0;
        for (int i = 0; i < 6; i++)
        {
            baseCoordinateScalar += facet[i] * rayCoordinatesMultiplesToBaseCoordinate[i];
        }

        float baseCoordinate = 1 / baseCoordinateScalar;

        // find the intersection point
        float[] intersection = new float[6];
        for (int i = 0; i < 6; i++)
        {
            intersection[i] = baseCoordinate * rayCoordinatesMultiplesToBaseCoordinate[i];
        }

        return intersection;
    }


    // distance between the two wrenches
    private float CalculateSqrDistanceR6(float[] v1, float[] v2)
    {
        float result = 0;

        if (v1 == null) v1 = new float[6];
        for (int i = 0; i < 6; i++)
        {
            var difference = v1[i] - v2[i];
            result += difference * difference;
        }

        return result;
    }

    // retrieve results after the Lp problem is solved
    // returns the values for the independent variables (the dimensions) in order
    private float[] GetVarValuesFromResult(LinearModel solver)
    {
        float[] vals = new float[6];
        foreach (object keyVar in solver.VariableKeys)
        {
            Rational num = solver.GetValue(solver.GetIndexFromKey(keyVar));
            if (num.IsIndeterminate)
            {
                continue;
            }

            var val = (float) num.ToDouble();
            switch (keyVar)
            {
                case "X0":
                    vals[0] = val;
                    break;
                case "X1":
                    vals[1] = val;
                    break;
                case "X2":
                    vals[2] = val;
                    break;
                case "X3":
                    vals[3] = val;
                    break;
                case "X4":
                    vals[4] = val;
                    break;
                case "X5":
                    vals[5] = val;
                    break;
                case "OF": // objective function
                    break;
                case "C": // constant term
                    break;
                default:
                    throw new InvalidOperationException("unknown var name in Lp solver: " + keyVar);
            }

        }


        return vals;
    }

    // returns a wrench built from force and toque
    // if is_normalized is set to true: the wrench will have a magnitude of 1
    private float[] CreateWrench(Vector3 force, Vector3 torque, bool is_normalized = false)
    {
        var wrench = new float[6] {force.x, force.y, force.z,
            torque.x, torque.y, torque.z};

        if (is_normalized)
        {
            float magnitude = (float)Math.Sqrt(force.sqrMagnitude + torque.sqrMagnitude);
            for (var i = 0; i < 6; i++)
            {
                wrench[i] /= magnitude;
            }
        }
        

        //// check magnitude = 1
        //float sqrMagnitude = 0;
        //foreach (var cell in wrench)
        //{
        //    sqrMagnitude += cell * cell;
        //}
        //print(sqrMagnitude);

        return wrench;
    }




    // return in degrees
    public static float GetAngleBetweenVectors(Vector3 v1, Vector3 v2)
    {
        float dot = Vector3.Dot(v1, v2);
        float m1 = v1.magnitude;
        float m2 = v2.magnitude;

        return (float) ((Math.Acos(dot / (m1 * m2))) * 180 /  Math.PI);
    }


    // returns the rotation matrix for rotating around the pixit axis for the given angles
    // angle in degrees
    public static Matrix4x4 GetRotationMatix(Vector3 normalizedPivitAxis, float angle)
    {
        float radians =  angle * (float) Math.PI / 180;
        float cos = (float) Math.Cos(radians);
        float sin = (float) Math.Sin(radians);

        float ax = normalizedPivitAxis.x;
        float ay = normalizedPivitAxis.y;
        float az = normalizedPivitAxis.z;


        var matrix = Matrix4x4.identity;

        matrix.SetRow(0, new Vector4(cos + ax * ax * (1 - cos), ax * ay * (1 - cos) - az * sin, ax * az * (1 - cos) + ay * sin, 0));
        matrix.SetRow(1, new Vector4(ay * ax * (1 - cos) + az * sin, cos + ay * ay * (1 - cos), ay * az * (1 - cos) - ax * sin, 0));
        matrix.SetRow(2, new Vector4(az * ax * (1 - cos) - ay * sin, az * ay * (1 - cos) + ax * sin, cos + az * az * (1 - cos), 0));
        matrix.SetRow(3, new Vector4(0, 0, 0, 1));


        return matrix;
    } 


    // calculates the quality
    public double CalculateQualityMeasure(bool is_subThread = false)
    {
        RaycastHit hit;
        float collisionCheckDistance = 0f;
        directionTowardsHandModel = HandModel.transform.position - transform.position;

        _subjectRigidbody.SweepTest(directionTowardsHandModel, out hit);

        collisionCheckDistance = hit.distance;

        if (_contacts.Count == 0)
        {
            var s = collisionCheckDistance > 0 ? -collisionCheckDistance : 0.0;
            ScoreBuffer = s;
            return s;
        }

        bool is_forceClosure = CheckForceClosure();
        if (!is_forceClosure)
        {
            ScoreBuffer = 0;
            return 0;
        }

        double score = 0;

        if (is_subThread)
        {
            ThreadStart ts = new ThreadStart(() =>
            {
                Is_calculatingQualty = true;
                try
                {
                    score = CalculateMaxWrenchOnSpecifiedDirections();
                }
                catch
                {
                    score = 0;
                }
                
                score *= ScoreMultiplier;
                ScoreBuffer = score;
                Is_calculatingQualty = false;
            });

            Thread t = new Thread(ts);
            t.Start();
            return 0;
        }


        score = CalculateMaxWrenchOnSpecifiedDirections();
        score *= ScoreMultiplier;
        return score;
        //return _is_overlay ? score * 0.5 : score;

    }

    // called after CheckForceClosure
    private double CalculateMaxWrenchOnSpecifiedDirections()
    {
        double minimumMaxLocalWrench = -1;
        int minIndex = 0;

        int index = 0;
        foreach (var wrenchDirection in qualityMeasureWrenchDirections)
        {
            var solver = SolveLpProblem(_constraints, wrenchDirection);
            var facet = GetVarValuesFromResult(solver);

            var intersection = CalculateRayInterSectionWithFacet(wrenchDirection, facet);
            var wrenchSqrMagnitude = CalculateSqrDistanceR6(null, intersection);

            //if (wrenchSqrMagnitude > 1)
            //{
            //    print(wrenchSqrMagnitude);
            //}

            if (minimumMaxLocalWrench == -1 || wrenchSqrMagnitude < minimumMaxLocalWrench)
            {
                minimumMaxLocalWrench = wrenchSqrMagnitude;
                minIndex = index;
            }
            index++;

        }



        return minimumMaxLocalWrench;

    }

    private double CalculateQualityOnSelectedPoints()
    {
        
        //List<float> distances = new List<float>();

        //distances.Clear();

        // maximum distance from defined contact point to the cloest point on the subject over all the defined contact points
        float maxDistance;
        List<Ray> imaginaryContactPointAndNormalPairs;

        try
        {
            imaginaryContactPointAndNormalPairs = 
                CalculateImaginaryContacts(out maxDistance, 
                out _, out _minDistanceCollider, out _closestPointOnSubject);
        }
        catch (Exception e)
        {
            UnityEngine.Debug.Log(e);
            return 0;
        }

        _imaginaryContacts = imaginaryContactPointAndNormalPairs;


        bool is_forceClosure = CheckForceClosure(imaginaryContactPointAndNormalPairs);

        if (!is_forceClosure) return 0;

        var score = CalculateMaxWrenchOnSpecifiedDirections();

        var distancePenalty = Math.Exp(-maxDistance * DistancePenaltyMultiplier);
        //print(handModelRb.worldCenterOfMass);
        //print(distancePenalty);
        return score * ScoreMultiplier * distancePenalty;

    }

    private double CalculateContactPointsQuality()
    {
        bool is_forceClosure = CheckForceClosure(_nextContactPoints);
        if (!is_forceClosure) return 0;

        var score = CalculateMaxWrenchOnSpecifiedDirections();
        return score * ScoreMultiplier;
    }


    private List<Ray> CalculateImaginaryContacts(out float maxDistance, 
        out float minDistance, out SphereCollider minDistanceCollider, out Ray? minDistancePointOnSubject)
    {
        List<Ray> imaginaryContactPointAndNormalPairs = new List<Ray>();
        float maximumDistance = 0f;
        float minimunDistance = float.PositiveInfinity;
        SphereCollider minimumDistanceCollider = null;
        Ray? minimumDistancePoint = null;
        foreach (var contactPoint in _selectedContactPoints)
        {
            var colliderPosition = contactPoint.transform.position;
            //float distance;
            Ray cloestPointOnSubject;
            float distanceCurr;

            cloestPointOnSubject = FindClosestPointAndItsNormalOnSubject(colliderPosition, out distanceCurr);
            if (distanceCurr > maximumDistance)
            {
                maxDistance = distanceCurr;
            }

            if(distanceCurr < minimunDistance)
            {
                minimunDistance = distanceCurr;
                minimumDistanceCollider = contactPoint;
                minimumDistancePoint = cloestPointOnSubject;
            }


            imaginaryContactPointAndNormalPairs.Add(cloestPointOnSubject);
            //distances.Add(distance);
        }
        maxDistance = maximumDistance;
        minDistance = minimunDistance;
        minDistanceCollider = minimumDistanceCollider;
        minDistancePointOnSubject = minimumDistancePoint;
        return imaginaryContactPointAndNormalPairs;
    }

    // find the closest point along with the surface normal on the subject reletive to the point given
    /*
     * point: the point in the world from which to find the closest point on the subject
     * distance: distance from the point to the closest point
     * colliderIndex: the index of the collider in SubjectColliders that is responsible for the closest point
     */
    private Ray FindClosestPointAndItsNormalOnSubject(Vector3 point, out float distance, out int colliderIndex)
    {
        int colliderCount = SubjectColliders.Length;

        Vector3[] closestPointsOnColliders = new Vector3[colliderCount];

        for (var i = 0; i < colliderCount; i++)
        {
            closestPointsOnColliders[i] = SubjectColliders[i].ClosestPoint(point);
            
        }

        var minDistance = Vector3.Distance(closestPointsOnColliders[0], point);
        int minIndex = 0;

        for (var i = 1; i < colliderCount; i++)
        {
            var distanceCurr = Vector3.Distance(closestPointsOnColliders[i], point);
            if (distanceCurr < minDistance)
            {
                minDistance = distanceCurr;
                minIndex = i;
            }
        }

        distance = minDistance;
        colliderIndex = minIndex;

        Ray pointToContactRay = new Ray(point, (closestPointsOnColliders[minIndex] - point).normalized);


        RaycastHit hit;
        if (!SubjectColliders[minIndex].Raycast(pointToContactRay, out hit, float.PositiveInfinity))
        {
            throw new Exception("a ray that is guranteed to hit did not hit");
        };

        return new Ray(hit.point, hit.normal);
    }

    private Ray FindClosestPointAndItsNormalOnSubject(Vector3 point, out float distance)
    {
        return FindClosestPointAndItsNormalOnSubject(point, out distance, out _);
    }


    // move the hand to make contact in the selected contact mode
    // this is a poor feature
    public void MakeContactOnClosestDefinedContact()
    {

        if (!_closestPointOnSubject.HasValue) return;

        var contactPosition = _closestPointOnSubject.Value.origin;
        var colliderPosition = _minDistanceCollider.transform.TransformPoint(_minDistanceCollider.center);
        var directionToMove = contactPosition - colliderPosition;
        var distanceToMove = Vector3.Distance(colliderPosition, contactPosition);


        _handModelDOF.MoveTowards(directionToMove, distanceToMove);

    }




    // compare the new contactPoint to the already existing contact points. 
    // if it has a distance less than a certain value with any existing contact point. this new contact point is considered the same as the existing contact point. 
    // returns the index for that existing contact point.
    // if no existing contact point is closest enough for the new contact point, returns -1.
    private int GetContactIndex(ContactPoint contactPoint)
    {
        for(var i=0; i< _contacts.Count; i++)
        {
            var contactPointStored = _contacts[i];
            if((contactPointStored.point - contactPoint.point).sqrMagnitude < 0.05)
            {
                return i;
            }
        }

        return -1;
    }

    private const string Thumb_File = "D:/VS_workspace/GraspSimulator/Assets/Models/HandR_v1/Data/Reachable_T.txt";
    private const string Index_File = "D:/VS_workspace/GraspSimulator/Assets/Models/HandR_v1/Data/Reachable_I.txt";
    private const string Middle_File = "D:/VS_workspace/GraspSimulator/Assets/Models/HandR_v1/Data/Reachable_M.txt";
    private const string Ring_File = "D:/VS_workspace/GraspSimulator/Assets/Models/HandR_v1/Data/Reachable_R.txt";
    private const string Pinky_File = "D:/VS_workspace/GraspSimulator/Assets/Models/HandR_v1/Data/Reachable_P.txt";
    private const string Vertices_File = "D:/VS_workspace/GraspSimulator/Assets/Models/HandR_v1/Data/Vertices.txt";
    private const string ContactPoint_File = "D:/VS_workspace/GraspSimulator/Assets/Models/HandR_v1/Data/ContactPoint.txt";

    private const string Thumb_File1 = "D:/VS_workspace/GraspSimulator/Assets/Models/HandR_v1/Data/Reachable_T_ALL.txt";
    private const string Index_File1 = "D:/VS_workspace/GraspSimulator/Assets/Models/HandR_v1/Data/Reachable_I_ALL.txt";
    private const string Middle_File1 = "D:/VS_workspace/GraspSimulator/Assets/Models/HandR_v1/Data/Reachable_M_ALL.txt";
    private const string Ring_File1 = "D:/VS_workspace/GraspSimulator/Assets/Models/HandR_v1/Data/Reachable_R_ALL.txt";
    private const string Pinky_File1 = "D:/VS_workspace/GraspSimulator/Assets/Models/HandR_v1/Data/Reachable_P_ALL.txt";


    //to save triangle vertices position array in text file
    public void SurfaceArea()
    {
        UnityEngine.Debug.Log("GraspPlanner Surface Area Contact Point Count: " + _contacts.Count);

    }

    List<Vector3> _surfaceContactPoint = new List<Vector3>();
    //List<ContactPoint> _surfaceContactPoint = new List<ContactPoint>();
    public bool MotionSimulateFlag = false;
    public int FingerFlag = 0;
    public bool colMoveControl = true;

    public void SurfaceContactPoint()
    {
        _surfaceContactPoint.Clear();
    }
    public void SurfaceContactPoint(int finger)
    {
        FingerFlag = finger + 1;
        String path = "";
        Vector3 surfaceContactPointPos = _contactPointsFilter[finger-1].point;
        //Vector3 pos;
        Vector3 xMax = new Vector3();
        Vector3 yMax = new Vector3();
        Vector3 zMax = new Vector3();
        float diff = 0;
        float tmp = 0;
        String path1 = "";

        switch (finger)
        {
            case 1:
                path = Thumb_File;
                path1 = Thumb_File1;
                break;
            case 2:
                path = Index_File;
                path1 = Index_File1;
                break;
            case 3:
                path = Middle_File;
                path1 = Middle_File1;
                break;
            case 4:
                path = Ring_File;
                path1 = Ring_File1;
                break;
            case 5:
                path = Pinky_File;
                path1 = Pinky_File1;
                break;
            default:
                break;
        }
        if (File.Exists(path))
        {
            File.Delete(path);
        }
        if (File.Exists(path1))
        {
            File.Delete(path1);
        }
        StreamWriter sw = File.CreateText(path);
        StreamWriter sw1 = File.CreateText(path1);

        foreach (var ContactPoint in _surfaceContactPoint)
        {
            sw1.WriteLine(ContactPoint.x + " " + ContactPoint.y + " " + ContactPoint.z);
        }


        for (int i=0; i< _surfaceContactPoint.Count; i++)
        {

        }

        foreach (var ContactPoint in _surfaceContactPoint)
        {
            diff = System.Math.Abs(ContactPoint.x - surfaceContactPointPos.x);
            if (diff > tmp)
            {
                xMax = ContactPoint;
                tmp = diff;
            }
        }

        tmp = 0;
        foreach (var ContactPoint in _surfaceContactPoint)
        {
            diff = System.Math.Abs(ContactPoint.y - surfaceContactPointPos.y);
            if (diff > tmp)
            {
                yMax = ContactPoint;
                tmp = diff;
            }
        }

        tmp = 0;
        foreach (var ContactPoint in _surfaceContactPoint)
        {
            diff = System.Math.Abs(ContactPoint.z - surfaceContactPointPos.z);
            if (diff > tmp)
            {
                zMax = ContactPoint;
                tmp = diff;
            }
        }

        sw.WriteLine(surfaceContactPointPos.x + " " + surfaceContactPointPos.y + " " + surfaceContactPointPos.z);
        sw.WriteLine(xMax.x + " " + xMax.y + " " + xMax.z);
        sw.WriteLine(yMax.x + " " + yMax.y + " " + yMax.z);
        sw.WriteLine(zMax.x + " " + zMax.y + " " + zMax.z);
        sw.Close();

        sw1.Close();

        _surfaceContactPoint.Clear();
    }


    private ContactPoint[] _contactPointsFilter = new ContactPoint[5];    //Store five contact points
    public void ContactPointFilter()
    {
        String objectName;
        Vector3 fPos;
        float tmp = 0;
        float minDistance = 0;

        Array.Clear(_contactPointsFilter, 0, _contactPointsFilter.Length);

        for (int i = 1; i <= 5; i++)
        {
            minDistance = 10000;
            objectName = "DP" + i + "_end";
            fPos = GameObject.FindGameObjectWithTag(objectName).transform.position;

            foreach (var contact in _contacts)
            {
                tmp = Vector3.Distance(contact.point, fPos);
                if(tmp < minDistance)
                {
                    minDistance = tmp;
                    _contactPointsFilter[i - 1] = contact;
                }
            }

        }

        if (File.Exists(ContactPoint_File))
        {
            File.Delete(ContactPoint_File);
        }
        StreamWriter sw = File.CreateText(ContactPoint_File);

        for(int i = 0; i < 5; i++)
        {
            sw.WriteLine(_contactPointsFilter[i].point.x + " " + _contactPointsFilter[i].point.y + " " + _contactPointsFilter[i].point.z);
        }

        sw.Close();
    }
    public void ComputeReachable()
    {

        ProcessStartInfo pythonInfo = new ProcessStartInfo();
        Process python;
        pythonInfo.FileName = "C:/Program Files/Python310/python.exe";
        pythonInfo.Arguments = "";
        pythonInfo.CreateNoWindow = false;
        pythonInfo.UseShellExecute = false;
        python = Process.Start(pythonInfo);
        python.WaitForExit();
        python.Close();

    }


    private void HandleCollision(Collision collision)
    {
        try
        {
            //print(_is_calculatingQualty);
            if (Is_calculatingQualty) return;


            if (!Is_AccumulatingContacts)
            {
                _contacts.Clear();
            }


            if (Is_AccumulatingContacts)
            {
                for (int i = 0; i < collision.contactCount; i++)
                {
                    var contactPoint = collision.GetContact(i);
                    var index = GetContactIndex(contactPoint);


                    
                    //Quaternion rot = Quaternion.FromToRotation(Vector3.up, collision.GetContact(i).normal);
                    //Vector3 pos = collision.GetContact(i).point;
                    //UnityEngine.Debug.Log("Collision Contact Point Info: " + pos);


                    if (index == -1)
                    {
                        _contacts.Add(contactPoint);
                    }

                }
                if (_contacts.Count > 100) _contacts.Clear();
            }
            else
            {
                for (int i = 0; i < collision.contactCount; i++)
                {
                    //UnityEngine.Debug.Log("Collision Contact Point Info: " + collision.GetContact(i));
                    _contacts.Add(collision.GetContact(i));

                }
            }   

            if (Is_manualControl)
            {
                //ClearPreviousContactPointsOnScreen();
                VisualiseContactPoints(_contacts);

                SurfaceArea();

                /*UnityEngine.Debug.Log("GraspPlanner Handle Collision " + _contacts.Count);
                foreach (var contact in _contacts)
                {
                   // Quaternion rot = Quaternion.FromToRotation(Vector3.up, contact.normal);
                   //Vector3 pos = contact.point;
                   //UnityEngine.Debug.Log("Contact Point Info Test Test: " + pos);


                }*/


                if (Is_QualityUpdatedOnCollisionStay)
                {
                    CalculateQualityMeasure(is_subThread: true);
                    Is_QualityUpdatedOnCollisionStay = false;
                }

            }

            //StopOtherCollider(collision);
        }
        catch (Exception)
        {
            if(_contacts != null)
            {
                _contacts.Clear();
            }
            
        }
        
    }

    private void OnCollisionEnter(Collision collision)
    {
        //    if (Is_manualControl) return;

        //    HandleCollision(collision);

        //    //CheckOverlay();
        //String colName = collision.collider.name;    
        //String colNameNeeded = "DP" + FingerFlag;
        ////UnityEngine.Debug.Log("collision collider name : " + colName);
        //if (MotionSimulateFlag && colName.StartsWith(colNameNeeded))
        //{
        //    colMoveControl = false;
        //}
    }

    private void OnCollisionStay(Collision collision)
    {
        //if (!Is_manualControl) return;

        //if (!Is_updatingScoreOnCollisionStay) return;
        HandleCollision(collision);
        //Is_updatingScoreOnCollisionStay = false;

        String colName = collision.collider.name;
        String colNameNeeded = "DP" + FingerFlag.ToString();
        //UnityEngine.Debug.Log("collision collider name : " + colName);
        if (MotionSimulateFlag && colName.StartsWith(colNameNeeded))
        {
            colMoveControl = false;
        }
    }

    private void OnCollisionExit(Collision collision)
    {
        for (int i = 0; i < collision.contactCount; i++)
        {
            var contactPoint = collision.GetContact(i);
            var index = GetContactIndex(contactPoint);
            if (index != -1)
            {
                _contacts.Remove(contactPoint);
            }

        }

        StopOtherCollider(collision);
    }

    private void StopOtherCollider(Collision collision)
    {
        var otherObject = collision.gameObject;
        var rb = otherObject.GetComponent<Rigidbody>();
        if (rb != null)
        {
            rb.velocity = Vector3.zero;
            rb.angularVelocity = Vector3.zero;
        }
    }



    public void ClearContacts()
    {
        _contacts.Clear();
    }

   


    private void VisualiseContactPoints(List<ContactPoint> contacts)
    {
        if (contacts == null) return;
        foreach (var contact in contacts)
        {
            Vector3 position = contact.point;
            String colliderName = contact.otherCollider.name;
            String colliderNameNeeded = "DP" + FingerFlag;
            _visualisedContactPoints.Add(Instantiate(ContactPointPrefab, position, Quaternion.identity));
            if (MotionSimulateFlag && colliderName.StartsWith(colliderNameNeeded))
            {
                UnityEngine.Debug.Log("contact colliderName : " + colliderName);
                if (!_surfaceContactPoint.Contains(position))
                {
                    _surfaceContactPoint.Add(position);
                }
                UnityEngine.Debug.Log("_surfaceContactPoint count : " + _surfaceContactPoint.Count);
            }
            else
            {
                //_visualisedContactPoints.Add(Instantiate(ContactPointPrefab, position, Quaternion.identity));
            }
        }
    }



    // visualize contact points with the contact point prefab
    public void VisualiseContactPoints()
    {
        if (Is_ContactPointOptimizer)
        {
            //UnityEngine.Debug.Log("Is_ContactPointOptimizer");
            foreach (var contact in _lastAcceptedContactPoints)
            {
                Vector3 position = contact.origin;
                _visualisedContactPoints.Add(Instantiate(ContactPointPrefabRed, position, Quaternion.identity));
            }
        }
        else if (Is_selectedContact)
        {
            //UnityEngine.Debug.Log("Is_selectedContact");
            foreach (var contact in _lastAcceptedImaginaryContacts)
            {
                Vector3 position = contact.origin;
                _visualisedContactPoints.Add(Instantiate(ContactPointPrefab, position, Quaternion.identity));
            }
        }
        else
        {
            VisualiseContactPoints(_lastAcceptedContacts);
        }

    }

    public void ClearPreviousContactPointsOnScreen()
    {
        foreach (var contactPoint in _visualisedContactPoints)
        {
            Destroy(contactPoint);
        }

        _visualisedContactPoints.Clear();
    }


    private Vector3 RandomPoint()
    {
        const float range = 5f;

        var point = new Vector3(
            _subjectCenterOfMass.x + Random.Range(-range, range),
            _subjectCenterOfMass.y + Random.Range(-range,range),
            _subjectCenterOfMass.z + Random.Range(-range, range)
            );

        return point;
    }


    public Vector3 RandomPointOutsideBounds(Bounds bounds)
    {
        Vector3 randomPoint;
        do
        {
            randomPoint = RandomPoint();
        } while (bounds.Contains(randomPoint));

        //Instantiate(RayIndicatorPrefab, randomPoint, Quaternion.identity);
        return randomPoint;
    }

    private void ComputeNextRandomContactPoints()
    {
        _nextContactPoints.Clear();
        for(var i=0; i<_contactCount; i++)
        {
            var pointOutsideSubject = RandomPointOutsideBounds(_subjectCollidersBounds);
            var pointOnSubject = FindClosestPointAndItsNormalOnSubject(pointOutsideSubject,out _);

            //var cp = SubjectColliders[0].ClosestPoint(pointOutsideSubject);
            _nextContactPoints.Add(pointOnSubject);
        }
    }

    // shows the ray indicator at a certain position pointing to a certain direction
    // for debugging purposes.
    private GameObject ShowRayIndicator(Vector3 position, Vector3 direction)
    {
        var indicator = Instantiate(RayIndicatorPrefab, position, Quaternion.identity);

        indicator.transform.up = direction;
        return indicator;
    }


    // test the rotation matrix
    private void TestRotationMatrix()
    {

        // test on basis vectors
        Vector3 normal = new Vector3(0, 0, 1);
        Vector3 edge0 = new Vector3(1, 0, 0);

        // check orthogonality
        UnityEngine.Debug.Assert(((int)Math.Round(Vector3.Dot(edge0, normal))) == 0);


        // rotate 0
        Matrix4x4 r = GetRotationMatix(normal, 0);
        Vector3 result = r.MultiplyVector(edge0);

        float angelRotated = GetAngleBetweenVectors(edge0, result);

        UnityEngine.Debug.Assert(((int)Math.Round(angelRotated)) == 0, angelRotated);

        // rotate 90
        r = GetRotationMatix(normal, 90);
        result = r.MultiplyVector(edge0);
        angelRotated = GetAngleBetweenVectors(edge0, result);
        UnityEngine.Debug.Assert(((int)Math.Round(angelRotated)) == 90, angelRotated);

        // rotate 180
        r = GetRotationMatix(normal, 180);
        result = r.MultiplyVector(edge0);
        angelRotated = GetAngleBetweenVectors(edge0, result);
        UnityEngine.Debug.Assert(((int)Math.Round(angelRotated)) == 180, angelRotated);

        // rotate -50
        r = GetRotationMatix(normal, -50);
        result = r.MultiplyVector(edge0);
        angelRotated = GetAngleBetweenVectors(edge0, result);
        UnityEngine.Debug.Assert(((int)Math.Round(angelRotated)) == 50, angelRotated);


        // test on random vector
        // random normalized vector
        normal =
            new Vector3((float)_rand.NextDouble(), (float)_rand.NextDouble(), (float)_rand.NextDouble()).normalized;
        float frictionCoefficient = 0.4f;



        float edgeY = (float)Math.Sqrt(
                (frictionCoefficient * frictionCoefficient) * (normal.z * normal.z) /
                (normal.z * normal.z + normal.y * normal.y));
        // vector orthogonal to the normal
        edge0 = new Vector3(0, edgeY, -(normal.y * edgeY) / normal.z);


        // rotate 90
        r = GetRotationMatix(normal, 90);
        result = r.MultiplyVector(edge0);
        angelRotated = GetAngleBetweenVectors(edge0, result);
        UnityEngine.Debug.Assert(((int)Math.Round(angelRotated)) == 90, angelRotated);

        //// rotate 180
        //r = GetRotationMatix(normal, 180);
        //result = r.MultiplyVector(edge0);
        //angelRotated = GetAngleBetweenVectors(edge0, result);

        //Debug.Assert(((int)Math.Round(angelRotated)) == 180, angelRotated);

        // rotate -50
        r = GetRotationMatix(normal, -50);
        result = r.MultiplyVector(edge0);
        angelRotated = GetAngleBetweenVectors(edge0, result);
        UnityEngine.Debug.Assert(((int)Math.Round(angelRotated)) == 50, angelRotated);

        // rotate 30
        r = GetRotationMatix(normal, 30);
        result = r.MultiplyVector(edge0);
        angelRotated = GetAngleBetweenVectors(edge0, result);
        UnityEngine.Debug.Assert(((int)Math.Round(angelRotated)) == 30, angelRotated);
    }


    private void TestLpSolver()
    {
        /*
            scenario 1
            P = 6x + 5y + 4z
            2x + y + z <= 180
            x + 3y + 2z <= 300
            2x + y + 2z <= 240
            result should be X=48 Y=84 Z=0 P=708 
        */
        float[] goal = new float[]
        {
            6, 5, 4
        };

        List<float[]> A = new List<float[]>();
        A.Add(new float[] { 2, 1, 1, 180 });
        A.Add(new float[] { 1, 3, 2, 300 });
        A.Add(new float[] { 2, 1, 2, 240 });

        SimplexSolver solver = SolveLpProblem(A, goal);

        UnityEngine.Debug.Assert(solver.Result != LinearResult.Invalid);


        int rid;
        object key;
        bool isMinimize, isOptimal;
        solver.GetSolvedGoal(0, out key, out rid, out isMinimize, out isOptimal);
        UnityEngine.Debug.Assert(!isMinimize);
        double resultVal = (double)solver.GetValue(rid);
        UnityEngine.Debug.Assert((int)resultVal == 708);


        foreach (object keyVar in solver.VariableKeys)
        {
            Rational num = solver.GetValue(solver.GetIndexFromKey(keyVar));
            if (num.IsIndeterminate)
            {
                continue;
            }

            switch (keyVar)
            {
                case "X0":
                    UnityEngine.Debug.Assert((int)num == 48, num);
                    break;
                case "X1":
                    UnityEngine.Debug.Assert((int)num == 84, num);
                    break;
                case "X2":
                    UnityEngine.Debug.Assert((int)num == 0, num);
                    break;
            }

        }


        /*
         * scenario 2
         *  P = 100000 X + 40000 Y + 18000 Z
         *  2000X + 600Y + 300Z <= 18200
         *  Y <= 10
         * -9X + Y + Z <= 0
         * -X -Y + Z <= 0
         * result: X=4 Y=10 Z=14 P=1052000
         */


        goal = new float[]
        {
            100000, 40000, 18000
        };


        A.Clear();
        A.Add(new float[] { 2000, 600, 300, 18200 });
        A.Add(new float[] { 0, 1, 0, 10 });
        A.Add(new float[] { -9, 1, 1, 0 });
        A.Add(new float[] { -1, -1, 1, 0 });


        solver = SolveLpProblem(A, goal);

        UnityEngine.Debug.Assert(solver.Result == LinearResult.Optimal);


        solver.GetSolvedGoal(0, out key, out rid, out isMinimize, out isOptimal);
        UnityEngine.Debug.Assert(!isMinimize);
        resultVal = (double)solver.GetValue(rid);
        UnityEngine.Debug.Assert((int)resultVal == 1052000);


        foreach (object keyVar in solver.VariableKeys)
        {
            Rational num = solver.GetValue(solver.GetIndexFromKey(keyVar));
            if (num.IsIndeterminate)
            {
                continue;
            }

            switch (keyVar)
            {
                case "X0":
                    UnityEngine.Debug.Assert((int)num == 4, num);
                    break;
                case "X1":
                    UnityEngine.Debug.Assert((int)num == 10, num);
                    break;
                case "X2":
                    UnityEngine.Debug.Assert((int)num == 14, num);
                    break;
            }

        }



    }

}
